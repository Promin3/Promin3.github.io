---
layout: post
title: DNN深度神经网络
date:  2023-11-7
tags: [cs]
comments: true
author: kevin
---



**以下内容来自[刘建平](https://link.zhihu.com/?target=http%3A//www.cnblogs.com/pinard/)Pinard-博客园的学习笔记，总结如下：**

深度神经网络（Deep Neural Networks， 以下简称DNN）是深度学习的基础，而要理解DNN，首先我们要理解DNN模型，下面我们就对DNN的模型与前向传播算法做一个总结。

## **1 从感知机到神经网络**

感知机的模型，它是一个有若干输入和一个输出的模型，如下图:

![img](https://pic1.zhimg.com/80/v2-8309413cef2521d53a8e0f8b82bc0e0c_1440w.webp)

输出和输入之间学习到一个线性关系，得到中间输出结果：

![img](https://pic4.zhimg.com/80/v2-91698dfe8a2cbf280d728fcda98dc6fb_1440w.webp)

接着是一个神经元激活函数：

![img](https://pic3.zhimg.com/80/v2-8d892ca795f7ef652b1b63a0f2335052_1440w.webp)

从而得到想要的结果1或者-1.

这个模型只能用于二元分类，且无法学习比较复杂的非线性模型，因此在工业界无法使用。而神经网络则在感知机的模型上做了扩展，总结下主要有三点：

（1）**加入了隐藏层**，隐藏层可以有多层，增强模型的表达能力，如下图实例，当然增加了这么多隐藏层模型的复杂度也增加了好多。

![img](https://pic3.zhimg.com/80/v2-ccaa2c07cfe1db5fcfbdb2a5829c58ca_1440w.webp)

（2）**输出层的神经元也可以不止一个输出，可以有多个输出**，这样模型可以灵活的应用于分类回归，以及其他的机器学习领域比如降维和聚类等。多个神经元输出的输出层对应的一个实例如下图，输出层现在有4个神经元了。

![img](https://pic2.zhimg.com/80/v2-4371e69571283b1bc4c2515e1af66f71_1440w.webp)

（3）对激活函数做扩展，感知机的激活函数是 ,虽然简单但是处理能力有限，因此神经网络中一般使用的其他的激活函数，比如我们在逻辑回归里面使用过的Sigmoid函数，即：



还有后来出现的tanx, softmax,和ReLU等。通过使用不同的激活函数，神经网络的表达能力进一步增强。

## **2 DNN的基本结构**

神经网络是基于感知机的扩展，而DNN可以理解为有很多隐藏层的神经网络。多层神经网络和深度神经网络DNN其实也是指的一个东西，DNN有时也叫做多层感知机（Multi-Layer perceptron,MLP）。

　　从DNN按不同层的位置划分，DNN内部的神经网络层可以分为三类，输入层，隐藏层和输出层,如下图示例，一般来说第一层是输入层，最后一层是输出层，而中间的层数都是隐藏层。

![img](https://pic4.zhimg.com/80/v2-1afa0c7d95bea01c038d82deca9d683b_1440w.webp)

层与层之间是全连接的，也就是说，第i层的任意一个神经元一定与第i+1层的任意一个神经元相连。虽然DNN看起来很复杂，但是从小的局部模型来说，还是和感知机一样，即一个线性关系 加上一个激活函数 。

由于DNN层数多，则我们的线性关系系数w和偏倚b的数量也就是很多了。具体的参数在DNN是如何定义的呢？

**首先看线性关系系数w的定义。**以下图一个三层的DNN为例，第二层的第4个神经元到第三层的第2个神经元的线性关系定义为 .上标3代表线性系数w所在的层数，而下标对应的是输出的第三层索引2和输入的第二层索引4。你也许会问，为什么不是 呢？这主要是为了便于模型用于矩阵表示运算，如果是 而每次进行矩阵运算是 ，需要进行转置。将输出的索引放在前面的话，则线性运算不用转置，即直接为 。第l−1层的第k个神经元到第l层的第j个神经元的线性系数定义为 。注意，输入层是没有w参数的。

![img](https://pic2.zhimg.com/80/v2-64f27adb53a7a8f142b40462ac977c61_1440w.webp)

**再看偏倚b的定义。**还是以这个三层的DNN为例，第二层的第三个神经元对应的偏倚定义为 .其中，上标2代表所在的层数，下标3代表偏倚所在的神经元的索引。同样的道理，第三层的第一个神经元的偏倚应该表示为 .输出层是没有偏倚参数的。

![img](https://pic1.zhimg.com/80/v2-21fc3ed328124c126b9db46f766524b4_1440w.webp)

## **3 DNN前向传播算法数学原理**

假设选择的激活函数是 ，隐藏层和输出层的输出值为 ，则对于下图的三层DNN,利用和感知机一样的思路，我们可以利用上一层的输出计算下一层的输出，也就是所谓的DNN前向传播算法。

![img](https://pic4.zhimg.com/80/v2-fe629aacecd2632fe375ea3b4e8184e7_1440w.webp)

![img](https://pic4.zhimg.com/80/v2-5bfc2403fcb0a7c1c5af728e8ff15fdb_1440w.webp)

从上面可以看出，使用代数法一个个的表示输出比较复杂，而如果使用矩阵法则比较的简洁。假设第l−1层共有m个神经元，而第l层共有n个神经元，则第l层的线性系数w组成了一个n×m的矩阵 。第l层的偏倚b组成了一个 的向量 ，第l-1层的输出 组成了一个 的向量 ，第l层的未激活前线性输出z组成了一个 的向量 ，第l层的输出 组成了一个 的向量 。用矩阵法表示，第l层的输出为：

![img](https://pic2.zhimg.com/80/v2-8946f3d8e49373716c622ebff2540ca9_1440w.webp)

## **4 DNN前向传播算法**

所谓的DNN前向传播算法就是利用若干个权重系数矩阵W,偏倚向量b来和输入值向量x进行一系列线性运算和激活运算，从输入层开始，一层层的向后计算，一直到运算到输出层，得到输出结果为值。

输入: 总层数L，所有隐藏层和输出层对应的矩阵W,偏倚向量b，输入值向量x

输出：输出层的输出。

![img](https://pic1.zhimg.com/80/v2-1543466ea9e7856e8cad97321347c588_1440w.webp)

## **5 DNN反向传播算法要解决的问题**

假设我们有m个训练样本 ，其中x为输入向量，特征维度为n_in，而y为输出向量，特征维度为n_out。我们需要利用这m个样本训练出一个模型，当有一个新的测试样本 时，可以预测 向量的输出。

如果我们采用DNN的模型，即我们使输入层n_in个神经元，而输出层有n_out个神经元。再加上一些含有若干神经元的隐藏层。此时需要找到合适的所有隐藏层和输出层对应的线性系数矩阵 ，偏倚向量 ，让所有的训练样本输入计算出的输出尽可能的等于或很接近样本输出。怎么找到合适的参数呢？

可以用一个合适的损失函数来度量训练样本的输出损失，接着对这个损失函数进行优化求最小化的极值，对应的一系列线性系数矩阵W,偏倚向量b即为我们的最终结果。在DNN中，**损失函数优化极值求解的过程**最常见的一般是通过梯度下降法来一步步迭代完成的，也可以是其他的迭代方法比如牛顿法与拟牛顿法。

## **6 DNN反向传播算法的基本思路**

在进行DNN反向传播算法前，我们需要选择一个损失函数，来度量训练样本计算出的输出和真实的训练样本输出之间的损失。

DNN可选择的损失函数有不少，为了专注算法，这里使用最常见的均方差来度量损失。即对于每个样本，我们期望最小化下式：

![img](https://pic2.zhimg.com/80/v2-cfcbddcc8bb1db7b8dcc802bc67ea669_1440w.webp)

损失函数有了，用梯度下降法迭代求解每一层的w,b。

**首先是输出层第 层。**注意到输出层的W,b满足下式：

![img](https://pic1.zhimg.com/80/v2-3290ce1f8f27004db47eca9caa45d27c_1440w.webp)

对于输出层的参数，损失函数变为：

![img](https://pic4.zhimg.com/80/v2-21f02bf1408d9b970429e3fd5a9e1217_1440w.webp)

求解W,b的梯度：

![img](https://pic3.zhimg.com/80/v2-e690fbccd7fe8894f6626c0a465d3c2e_1440w.webp)

![img](https://pic4.zhimg.com/80/v2-89b800e63c676d1877607b196b64ecdb_1440w.webp)

![img](https://pic1.zhimg.com/80/v2-48e1ea67c928258507ca6814314b42f0_1440w.webp)

## **7 DNN反向传播算法过程**

由于梯度下降法有批量（Batch），小批量(mini-Batch)，随机三个变种，为了简化描述，这里我们以最基本的批量梯度下降法为例来描述反向传播算法。实际上在业界使用最多的是mini-Batch的梯度下降法。区别仅仅在于迭代时训练样本的选择。

输入：总层数 ，以及各隐藏层与输出层的神经元个数，激活函数，损失函数，迭代步长 ，最大迭代次数 与停止迭代阈值 ，输入的m个训练样本

输出：各隐藏层与输出层的线性关系系数矩阵W和偏倚向量。

![img](https://pic4.zhimg.com/80/v2-1581316b33944233af88b967ad2901b7_1440w.webp)

## **8 均方差损失函数+Sigmoid激活函数的问题**

在讲反向传播算法时，我们用均方差损失函数和Sigmoid激活函数做了实例，首先我们就来看看均方差+Sigmoid的组合有什么问题。

首先我们回顾下Sigmoid激活函数的表达式为：



 的函数图像如下：

![img](https://pic1.zhimg.com/80/v2-563f287164d1b833395afe298b228f58_1440w.webp)

从上图可以看出，对于Sigmoid，当z的取值越来越大后，函数曲线变得越来越平缓，意味着此时的导数 也越来越小。同样的，当z的取值越来越小时，也有这个问题。仅仅在z取值为0附近时，导数 的取值较大。

在均方差+Sigmoid的反向传播算法中，每一层向前递推都要乘以 ，得到梯度变化值。Sigmoid的这个曲线意味着在大多数时候，我们的梯度变化值很小，导致我们的

W,b更新到极值的速度较慢，也就是我们的算法收敛速度较慢。那么有什么什么办法可以改进呢？

## **9 交叉熵损失函数+Sigmoid激活函数改进DNN算法收敛速度**

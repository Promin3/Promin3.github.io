---
layout: post
title: P问题、NP问题、NPC问题和NP难问题
date:   2023-9-5
tags: [cs]
comments: true
author: kevin
---



P问题：有多项式时间算法，算得很快的问题。

NP问题：算起来不确定快不快的问题，但是我们可以快速验证这个问题的解。

NP-complete问题：属于NP问题，且属于NP-hard问题。

NP-hard问题：比NP问题都要难的问题。

详细说一下这四个问题：

开始之前先说明两个概念：多项式，时间复杂度（知道的请自动跳过）。

1.多项式：$ax^n + bx^{n-1}+c$ ，形如这种形式的就被称为x的最高位为n的多项式。

2.时间复杂度：定义为随着问题规模的增大，算法执行时间增长的快慢。它可以用来表示一个算法运行的时间效率。举个例子，冒泡排序的时间复杂度为 ,取其最高次，可以看出，这是一个时间复杂度为多项式的表示方式。

好了，介绍完上面的概念就可以开始讲关于什么叫P类问题了。以上个例子冒泡排序为例，我们知道了，在排序这个大问题里，是可以找到一种时间复杂度为多项式的算法(如冒泡排序法)来求解排序问题的，所以我们说排序问题是一个有多项式时间算法的问题。

1.**P类问题**：存在多项式时间算法的问题。(P：polynominal，多项式)。

我们为什么要研究这个P类问题呢？当计算机处理的数据达到100万个的时候，时间复杂度分别为 和 的算法，运行时间简直就是天壤之别。所以我们才要研究一个问题是否具有多项式时间的算法。

2.**NP问题**：能在多项式时间内验证得出一个正确解的问题。(NP:Nondeterministic polynominal，非确定性多项式)。

这里可以清楚的看出**P类问题是NP类问题的子集**（即存在多项式时间算法的问题，总能在多项式时间内验证它）

个人理解NP类问题就是，不知道这个问题存不存在一个多项式时间的算法，所以叫非确定性（non-deterministic）。但是我们可以在多项式时间内验证并得出这个问题的一个正确解。举个例子：

著名的NP类问题：旅行家推销问题(TSP)。即有一个推销员，要到n个城市推销商品，他要找出一个包含所有n个城市的环路，这个环路路径小于a。我们知道这个问题如果单纯的用枚举法来列举的话会有(n-1)! 种，已经不是多项式时间的算法了，(注：阶乘算法比多项式的复杂)。那怎么办呢？我们可以用猜的，假设人品爆炸猜几次就猜中了一条小于长度a的路径，TSP问题解决了，皆大欢喜。可是，我不可能每次都猜的那么准，也许我要猜完所有种方案呢？所以我们说，这是一个NP类问题。也就是，我们能在多项式的时间内验证并得出问题的正确解，可是我们却不知道该问题是否存在一个多项式时间的算法，每次都能解决他(注意，这里是不知道，不是不存在)。

所以这就引出了这类讨论的一个千年问题：是否 NP类问题=P类问题？

即，是否所有能在多项式时间内验证得出正确解的问题，都是具有多项式时间算法的问题呢？

太让人震惊了，要是解决了这个问题，那岂不是所有的NP问题都可以通过计算机来解决？

为了证明这个千古难题，科学家想出了很多办法。其中之一就是问题的约化。所谓问题约化就是，可以用问题B的算法来解决A ，我们就说问题A可以约化成问题B。举个例子：一元一次方程的求解，跟二元一次方程的求解，我们知道，只要能求解二元一次方程，那就可以用二元一次方程的解法来求解一元一次方程，只需要将一元一次方程加上y，并附加一个方程y=0就可以将一元一次方程变形为一个二元一次方程，然后用二元一次方程的解法来求解这个方程。注意，这里二元一次方程的解法会比一元一次的复杂。所以我们说，只需要找到解二元一次方程的规则性解法，那就能用这个规则性解法来求解一元一次方程。从这里也可以看出，约化是具有传递性的，如A约化到B，B约化到C，A就可以约化到C，同时不断约化下去，我们会发现一个很惊人的特性，就是他一定会存在一个最大的问题，而我们只需要解决了这个问题，那其下的所有问题也就解决啦！这就是我们所说的NPC问题的概念！！！

引到NP问题里就是，对于同一类的所有的NP类问题，若他们都可以在多项式时间内约化成最难的一个NP类问题，（我们直观的认为，被约化成的问题应具有比前一个问题更复杂的时间复杂度）当我们针对这个时间复杂度最高的超级NP问题要是能找到他的多项式时间算法的话，那就等于变向的证明了其下的所有问题都是存在多项式算法的，即NP=P！！！！给出NPC问题定义。

3.**NPC类问题**（Nondeterminism Polynomial complete）：存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。其定义要满足2个条件： 

首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。

要证明npc问题的思路就是： 先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它。

4.**NP难问题**（NP-hard问题）：

NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广，NP-Hard问题没有限定属于NP），即所有的NP问题都能约化到它，但是它不一定是一个NP问题。

以上四个问题他们之间的关系可以用下图来表示：

![p、np、npc、nphard](https://raw.githubusercontent.com/Promin3/Promin3.github.io/main/images/20150727214918014.png)